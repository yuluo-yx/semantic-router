name: Operator CI

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'deploy/operator/**'
      - '.github/workflows/operator-ci.yml'
  pull_request:
    branches:
      - main
      - develop
    paths:
      - 'deploy/operator/**'
      - '.github/workflows/operator-ci.yml'

env:
  GO_VERSION: '1.24'

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./deploy/operator
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download dependencies
        run: go mod download

      - name: Run go fmt
        run: |
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "Code is not formatted:"
            gofmt -s -l .
            exit 1
          fi

      - name: Run go vet
        run: go vet ./...

      - name: Install golangci-lint
        run: |
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.64.2

      - name: Run golangci-lint
        run: $(go env GOPATH)/bin/golangci-lint run --timeout=5m

  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./deploy/operator
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        run: go test -v -race -coverprofile=coverage.out -covermode=atomic ./...

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./deploy/operator/coverage.out
          flags: operator
          name: operator-coverage

  manifests:
    name: Verify Manifests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./deploy/operator
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download dependencies
        run: go mod download

      - name: Install controller-gen
        run: |
          GOBIN=$(pwd)/bin go install sigs.k8s.io/controller-tools/cmd/controller-gen@v0.19.0

      - name: Generate manifests
        run: make manifests

      - name: Verify no changes
        run: |
          git diff --exit-code || (echo "Generated manifests are out of date. Run 'make manifests' and commit the changes." && exit 1)

  docker-build:
    name: Docker Build and Push
    if: github.repository == 'vllm-project/semantic-router'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up QEMU for multi-platform builds
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set lowercase repository owner
        run: echo "REPOSITORY_OWNER_LOWER=$(echo $GITHUB_REPOSITORY_OWNER | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set local tags for integration tests
        id: local-tags
        run: |
          echo "operator=semantic-router-operator:test" >> $GITHUB_OUTPUT
          echo "bundle=semantic-router-operator-bundle:test" >> $GITHUB_OUTPUT

      - name: Generate remote tags for operator
        id: operator-remote-tags
        if: github.event_name != 'pull_request'
        run: |
          TAG="${{ github.sha }}"
          TAGS="ghcr.io/${REPOSITORY_OWNER_LOWER}/semantic-router/operator:${TAG},ghcr.io/${REPOSITORY_OWNER_LOWER}/semantic-router/operator:latest"
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT

      - name: Generate remote tags for bundle
        id: bundle-remote-tags
        if: github.event_name != 'pull_request'
        run: |
          TAG="${{ github.sha }}"
          TAGS="ghcr.io/${REPOSITORY_OWNER_LOWER}/semantic-router/operator-bundle:${TAG},ghcr.io/${REPOSITORY_OWNER_LOWER}/semantic-router/operator-bundle:latest"
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT

      - name: Build operator image (local for tests)
        uses: docker/build-push-action@v5
        with:
          context: ./deploy/operator
          file: ./deploy/operator/Dockerfile
          platforms: linux/amd64
          push: false
          load: true
          tags: ${{ steps.local-tags.outputs.operator }}
          cache-from: type=gha,scope=operator
          cache-to: type=gha,mode=max,scope=operator

      - name: Build and push operator image (multi-arch to registry)
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: ./deploy/operator
          file: ./deploy/operator/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.operator-remote-tags.outputs.tags }}
          cache-from: type=gha,scope=operator

      - name: Build bundle image (local for tests)
        uses: docker/build-push-action@v5
        with:
          context: ./deploy/operator
          file: ./deploy/operator/bundle/Dockerfile
          platforms: linux/amd64
          push: false
          load: true
          tags: ${{ steps.local-tags.outputs.bundle }}
          cache-from: type=gha,scope=operator-bundle
          cache-to: type=gha,mode=max,scope=operator-bundle

      - name: Build and push bundle image (multi-arch to registry)
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: ./deploy/operator
          file: ./deploy/operator/bundle/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.bundle-remote-tags.outputs.tags }}
          cache-from: type=gha,scope=operator-bundle

      - name: Save operator image for integration tests
        run: docker save -o /tmp/operator-image.tar ${{ steps.local-tags.outputs.operator }}

      - name: Save bundle image for validation
        run: docker save -o /tmp/bundle-image.tar ${{ steps.local-tags.outputs.bundle }}

      - name: Upload operator image artifact
        uses: actions/upload-artifact@v4
        with:
          name: operator-image
          path: /tmp/operator-image.tar
          retention-days: 1

      - name: Upload bundle image artifact
        uses: actions/upload-artifact@v4
        with:
          name: bundle-image
          path: /tmp/bundle-image.tar
          retention-days: 1

  bundle-validate:
    name: Validate OLM Bundle
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./deploy/operator
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install operator-sdk
        run: |
          export ARCH=$(case $(uname -m) in x86_64) echo -n amd64 ;; aarch64) echo -n arm64 ;; *) echo -n $(uname -m) ;; esac)
          export OS=$(uname | awk '{print tolower($0)}')
          export OPERATOR_SDK_DL_URL=https://github.com/operator-framework/operator-sdk/releases/download/v1.34.1
          curl -LO ${OPERATOR_SDK_DL_URL}/operator-sdk_${OS}_${ARCH}
          chmod +x operator-sdk_${OS}_${ARCH}
          sudo mv operator-sdk_${OS}_${ARCH} /usr/local/bin/operator-sdk

      - name: Validate bundle
        run: operator-sdk bundle validate ./bundle

  integration-test:
    name: Integration Test (${{ matrix.cache-backend }})
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [docker-build]
    strategy:
      fail-fast: false
      matrix:
        cache-backend: [memory, redis, milvus, hybrid]
        include:
          - cache-backend: memory
            deploy-redis: false
            deploy-milvus: false
            router-name: test-router
          - cache-backend: redis
            deploy-redis: true
            deploy-milvus: false
            router-name: test-router-redis
          - cache-backend: milvus
            deploy-redis: false
            deploy-milvus: true
            router-name: test-router-milvus
          - cache-backend: hybrid
            deploy-redis: false
            deploy-milvus: true
            router-name: test-router-hybrid
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install kind
        run: |
          curl --retry 5 --retry-delay 5 --retry-all-errors -Lo ./kind https://kind.sigs.k8s.io/dl/v0.31.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.33.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/kubectl

      - name: Create kind cluster
        run: |
          cat <<EOF | kind create cluster --name operator-test-${{ matrix.cache-backend }} --image kindest/node:v1.33.7@sha256:d26ef333bdb2cbe9862a0f7c3803ecc7b4303d8cea8e814b481b09949d353040 --config=-
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
          - role: control-plane
          EOF
          kubectl cluster-info
          kubectl get nodes

      - name: Install Gateway API CRDs
        run: |
          echo "Installing Gateway API CRDs..."
          kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml
          kubectl wait --for condition=established --timeout=60s crd/gateways.gateway.networking.k8s.io
          kubectl wait --for condition=established --timeout=60s crd/httproutes.gateway.networking.k8s.io

      - name: Deploy Redis
        if: matrix.deploy-redis == true
        run: |
          echo "Deploying Redis..."
          kubectl create namespace cache-backends || true

          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: redis
            namespace: cache-backends
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: redis
            template:
              metadata:
                labels:
                  app: redis
              spec:
                containers:
                - name: redis
                  image: redis/redis-stack-server:latest
                  ports:
                  - containerPort: 6379
                    name: redis
                  resources:
                    requests:
                      cpu: 100m
                      memory: 256Mi
                    limits:
                      cpu: 500m
                      memory: 512Mi
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: redis
            namespace: cache-backends
          spec:
            selector:
              app: redis
            ports:
            - port: 6379
              targetPort: 6379
              name: redis
          EOF

          kubectl wait --for=condition=available --timeout=120s deployment/redis -n cache-backends
          echo "Redis deployed successfully"

      - name: Deploy Milvus
        if: matrix.deploy-milvus == true
        run: |
          echo "Deploying Milvus Standalone..."
          kubectl create namespace cache-backends || true

          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: milvus-standalone
            namespace: cache-backends
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: milvus-standalone
            template:
              metadata:
                labels:
                  app: milvus-standalone
              spec:
                containers:
                - name: milvus
                  image: milvusdb/milvus:v2.4.0
                  command:
                  - milvus
                  - run
                  - standalone
                  env:
                  - name: ETCD_USE_EMBED
                    value: "true"
                  - name: COMMON_STORAGETYPE
                    value: local
                  ports:
                  - containerPort: 19530
                    name: milvus
                  - containerPort: 9091
                    name: metrics
                  resources:
                    requests:
                      cpu: 500m
                      memory: 1Gi
                    limits:
                      cpu: 2000m
                      memory: 2Gi
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: milvus-standalone
            namespace: cache-backends
          spec:
            selector:
              app: milvus-standalone
            ports:
            - port: 19530
              targetPort: 19530
              name: milvus
            - port: 9091
              targetPort: 9091
              name: metrics
          EOF

          kubectl wait --for=condition=available --timeout=180s deployment/milvus-standalone -n cache-backends
          echo "Milvus deployed successfully"
          sleep 10

      - name: Create cache credentials secrets
        if: matrix.deploy-redis == true || matrix.deploy-milvus == true
        run: |
          kubectl create namespace semantic-router-test || true

          if [ "${{ matrix.deploy-redis }}" == "true" ]; then
            kubectl create secret generic redis-credentials \
              --from-literal=password=testpassword \
              -n semantic-router-test
          fi

          if [ "${{ matrix.deploy-milvus }}" == "true" ]; then
            kubectl create secret generic milvus-credentials \
              --from-literal=password=Milvus \
              -n semantic-router-test
          fi

      - name: Download operator image artifact
        uses: actions/download-artifact@v4
        with:
          name: operator-image
          path: /tmp

      - name: Load operator image into Docker
        run: docker load --input /tmp/operator-image.tar

      - name: Verify operator image loaded
        run: |
          echo "Verifying operator image is available..."
          docker images | grep semantic-router-operator || {
            echo "ERROR: semantic-router-operator:test image not found!"
            echo "Available images:"
            docker images
            exit 1
          }

      - name: Load operator image into kind
        run: kind load docker-image semantic-router-operator:test --name operator-test-${{ matrix.cache-backend }}

      - name: Verify operator image in kind
        run: |
          echo "Verifying operator image is available in kind cluster..."
          docker exec operator-test-${{ matrix.cache-backend }}-control-plane crictl images | grep semantic-router-operator || {
            echo "ERROR: semantic-router-operator:test image not found in kind!"
            echo "Available images in kind:"
            docker exec operator-test-${{ matrix.cache-backend }}-control-plane crictl images
            exit 1
          }

      - name: Install CRDs
        run: |
          cd deploy/operator
          make install

      - name: Deploy operator
        run: |
          cd deploy/operator
          # Update image in kustomization
          cd config/manager
          kustomize edit set image controller=semantic-router-operator:test
          cd ../..
          # Deploy operator
          make deploy IMG=semantic-router-operator:test

      - name: Wait for operator deployment to be created
        run: |
          echo "Waiting for operator deployment to be created..."
          for i in {1..30}; do
            DEPLOYMENT=$(kubectl get deployment -n semantic-router-operator-system -l control-plane=controller-manager -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            if [ -n "$DEPLOYMENT" ]; then
              echo "Found deployment: $DEPLOYMENT"
              echo "OPERATOR_DEPLOYMENT=$DEPLOYMENT" >> $GITHUB_ENV
              break
            fi
            echo "Waiting for deployment creation... (attempt $i/30)"
            sleep 2
          done
          if [ -z "$DEPLOYMENT" ]; then
            echo "ERROR: Deployment not found after 60 seconds"
            kubectl get all -n semantic-router-operator-system
            exit 1
          fi

      - name: Wait for operator deployment to be ready
        run: |
          kubectl wait --for=condition=available --timeout=120s \
            deployment/${{ env.OPERATOR_DEPLOYMENT }} \
            -n semantic-router-operator-system

      - name: Check operator logs
        if: always()
        run: |
          echo "=== Operator Logs ==="
          # Try to get deployment name from env, fallback to label selector
          DEPLOYMENT="${{ env.OPERATOR_DEPLOYMENT }}"
          if [ -z "$DEPLOYMENT" ]; then
            DEPLOYMENT=$(kubectl get deployment -n semantic-router-operator-system -l control-plane=controller-manager -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          fi
          if [ -n "$DEPLOYMENT" ]; then
            kubectl logs -n semantic-router-operator-system \
              deployment/$DEPLOYMENT \
              --all-containers --tail=100 || true
          else
            echo "Could not find operator deployment"
            kubectl get all -n semantic-router-operator-system || true
          fi

      - name: Create test namespace
        run: |
          kubectl create namespace semantic-router-test || true

      - name: Create test SemanticRouter CR
        run: |
          # Generate base CR configuration
          CACHE_CONFIG=""

          case "${{ matrix.cache-backend }}" in
            memory)
              CACHE_CONFIG='
              semantic_cache:
                enabled: true
                backend_type: "memory"
                max_entries: 100'
              ;;
            redis)
              CACHE_CONFIG='
              semantic_cache:
                enabled: true
                backend_type: "redis"
                similarity_threshold: "0.85"
                ttl_seconds: 3600
                embedding_model: "bert"
                redis:
                  connection:
                    host: redis.cache-backends.svc.cluster.local
                    port: 6379
                    database: 0
                    password_secret_ref:
                      name: redis-credentials
                      key: password
                    timeout: 30
                    tls:
                      enabled: false
                  index:
                    name: semantic_cache_idx
                    prefix: "cache:"
                    vector_field:
                      name: embedding
                      dimension: 384
                      metric_type: COSINE
                    index_type: HNSW
                    params:
                      M: 16
                      efConstruction: 64
                  search:
                    topk: 1
                  development:
                    drop_index_on_startup: false
                    auto_create_index: true
                    verbose_errors: true'
              ;;
            milvus)
              CACHE_CONFIG='
              semantic_cache:
                enabled: true
                backend_type: "milvus"
                similarity_threshold: "0.90"
                ttl_seconds: 7200
                embedding_model: "bert"
                milvus:
                  connection:
                    host: milvus-standalone.cache-backends.svc.cluster.local
                    port: 19530
                    database: semantic_router_cache
                    timeout: 30
                    auth:
                      enabled: true
                      username: root
                      password_secret_ref:
                        name: milvus-credentials
                        key: password
                    tls:
                      enabled: false
                  collection:
                    name: semantic_cache
                    description: "Semantic cache for LLM responses"
                    vector_field:
                      name: embedding
                      dimension: 384
                      metric_type: IP
                    index:
                      type: HNSW
                      params:
                        M: 16
                        efConstruction: 64
                  search:
                    params:
                      ef: 64
                    topk: 10
                    consistency_level: Session
                  performance:
                    connection_pool:
                      max_connections: 10
                      max_idle_connections: 5
                      acquire_timeout: 30
                    batch:
                      insert_batch_size: 100
                      timeout: 60
                  data_management:
                    ttl:
                      enabled: true
                      timestamp_field: created_at
                      cleanup_interval: 3600
                    compaction:
                      enabled: false
                      interval: 86400
                  development:
                    drop_collection_on_startup: false
                    auto_create_collection: true
                    verbose_errors: true'
              ;;
            hybrid)
              CACHE_CONFIG='
              semantic_cache:
                enabled: true
                backend_type: "hybrid"
                similarity_threshold: "0.85"
                ttl_seconds: 3600
                max_entries: 5000
                eviction_policy: lru
                embedding_model: "bert"
                hnsw:
                  use_hnsw: true
                  hnsw_m: 32
                  hnsw_ef_construction: 128
                  max_memory_entries: 5000
                milvus:
                  connection:
                    host: milvus-standalone.cache-backends.svc.cluster.local
                    port: 19530
                    database: semantic_router_cache
                    timeout: 30
                    auth:
                      enabled: true
                      username: root
                      password_secret_ref:
                        name: milvus-credentials
                        key: password
                    tls:
                      enabled: false
                  collection:
                    name: semantic_cache_hybrid
                    description: "Hybrid cache backend storage"
                    vector_field:
                      name: embedding
                      dimension: 384
                      metric_type: IP
                    index:
                      type: HNSW
                      params:
                        M: 32
                        efConstruction: 128
                  search:
                    params:
                      ef: 128
                    topk: 20
                    consistency_level: Eventually
                  performance:
                    connection_pool:
                      max_connections: 20
                      max_idle_connections: 10
                      acquire_timeout: 30
                    batch:
                      insert_batch_size: 200
                      timeout: 60
                  data_management:
                    ttl:
                      enabled: true
                      timestamp_field: created_at
                      cleanup_interval: 1800
                    compaction:
                      enabled: true
                      interval: 43200
                  development:
                    drop_collection_on_startup: false
                    auto_create_collection: true
                    verbose_errors: false'
              ;;
          esac

          cat <<EOF | kubectl apply -f -
          apiVersion: vllm.ai/v1alpha1
          kind: SemanticRouter
          metadata:
            name: ${{ matrix.router-name }}
            namespace: semantic-router-test
          spec:
            replicas: 1
            image:
              repository: ghcr.io/vllm-project/semantic-router/extproc
              tag: latest
              pullPolicy: IfNotPresent
            service:
              type: ClusterIP
              grpc:
                port: 50051
                targetPort: 50051
              api:
                port: 8080
                targetPort: 8080
            resources:
              limits:
                memory: "2Gi"
                cpu: "1"
              requests:
                memory: "1Gi"
                cpu: "500m"
            persistence:
              enabled: false
            startupProbe:
              enabled: true
              periodSeconds: 10
              timeoutSeconds: 5
              failureThreshold: 60
            config:
              bert_model:
                model_id: "models/mom-embedding-light"
                threshold: "0.6"
                use_cpu: true
          ${CACHE_CONFIG}
              tools:
                enabled: false
              prompt_guard:
                enabled: false
              classifier:
                category_model:
                  model_id: "models/lora_intent_classifier_bert-base-uncased_model"
                  use_cpu: true
                pii_model:
                  model_id: "models/pii_classifier_modernbert-base_presidio_token_model"
                  use_cpu: true
              api:
                batch_classification:
                  max_batch_size: 50
                  metrics:
                    enabled: true
              observability:
                tracing:
                  enabled: false
          EOF

      - name: Wait for SemanticRouter deployment to be created
        run: |
          echo "Waiting for deployment to be created..."
          for i in {1..30}; do
            if kubectl get deployment ${{ matrix.router-name }} -n semantic-router-test 2>/dev/null; then
              echo "Deployment found!"
              break
            fi
            echo "Waiting for deployment creation... (attempt $i/30)"
            sleep 2
          done

      - name: Verify resources created
        run: |
          echo "=== Checking Deployment ==="
          kubectl get deployment ${{ matrix.router-name }} -n semantic-router-test -o yaml || true

          echo "=== Checking Service ==="
          kubectl get service ${{ matrix.router-name }} -n semantic-router-test || true

          echo "=== Checking ConfigMap ==="
          kubectl get configmap -n semantic-router-test || true

          echo "=== Checking ServiceAccount ==="
          kubectl get serviceaccount -n semantic-router-test || true

          echo "=== Checking Pods ==="
          kubectl get pods -n semantic-router-test || true

      - name: Wait for semantic router pod to start
        run: |
          echo "Waiting for pod to be created..."
          for i in {1..60}; do
            POD_NAME=$(kubectl get pods -n semantic-router-test -l app.kubernetes.io/instance=${{ matrix.router-name }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            if [ -n "$POD_NAME" ]; then
              echo "Pod $POD_NAME found!"
              break
            fi
            echo "Waiting for pod creation... (attempt $i/60)"
            sleep 2
          done

      - name: Wait for semantic router pod to be ready
        run: |
          echo "Waiting for pod to be ready (downloading models may take several minutes)..."
          kubectl wait --for=condition=ready pod \
            -l app.kubernetes.io/instance=${{ matrix.router-name }} \
            -n semantic-router-test \
            --timeout=300s || {
              echo "Pod failed to become ready within 5 minutes"
              echo "=== Pod Status ==="
              kubectl get pods -n semantic-router-test -o wide
              echo "=== Pod Events ==="
              kubectl get events -n semantic-router-test --sort-by='.lastTimestamp'
              echo "=== Pod Logs ==="
              POD_NAME=$(kubectl get pods -n semantic-router-test -l app.kubernetes.io/instance=${{ matrix.router-name }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
              if [ -n "$POD_NAME" ]; then
                kubectl logs $POD_NAME -n semantic-router-test --all-containers --tail=100 || true
              fi
              exit 1
            }

      - name: Check semantic router pod status
        if: always()
        run: |
          echo "=== Pod Status ==="
          kubectl get pods -n semantic-router-test -o wide || true

          echo "=== Pod Events ==="
          kubectl get events -n semantic-router-test --sort-by='.lastTimestamp' || true

      - name: Get semantic router logs
        if: always()
        run: |
          POD_NAME=$(kubectl get pods -n semantic-router-test -l app.kubernetes.io/instance=${{ matrix.router-name }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$POD_NAME" ]; then
            echo "=== Semantic Router Pod Logs ==="
            kubectl logs $POD_NAME -n semantic-router-test --all-containers --tail=200 || true
          else
            echo "No pod found to get logs from"
          fi

      - name: Verify deployment reconciliation
        run: |
          echo "=== Checking SemanticRouter Status ==="
          kubectl get semanticrouter ${{ matrix.router-name }} -n semantic-router-test -o yaml || true

          echo "=== Verifying Deployment Exists ==="
          if kubectl get deployment ${{ matrix.router-name }} -n semantic-router-test; then
            echo "✓ Deployment successfully created by operator"
          else
            echo "✗ Deployment not found"
            exit 1
          fi

          echo "=== Verifying Service Exists ==="
          if kubectl get service ${{ matrix.router-name }} -n semantic-router-test; then
            echo "✓ Service successfully created by operator"
          else
            echo "✗ Service not found"
            exit 1
          fi

      - name: Test service connectivity
        run: |
          echo "=== Testing Service Endpoints ==="
          kubectl get endpoints -n semantic-router-test ${{ matrix.router-name }} || true

      - name: Upload operator logs
        if: always()
        run: |
          mkdir -p /tmp/operator-logs
          # Try to get deployment name from env, fallback to label selector
          DEPLOYMENT="${{ env.OPERATOR_DEPLOYMENT }}"
          if [ -z "$DEPLOYMENT" ]; then
            DEPLOYMENT=$(kubectl get deployment -n semantic-router-operator-system -l control-plane=controller-manager -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          fi
          if [ -n "$DEPLOYMENT" ]; then
            kubectl logs -n semantic-router-operator-system \
              deployment/$DEPLOYMENT \
              --all-containers > /tmp/operator-logs/operator.log || true
          fi

          POD_NAME=$(kubectl get pods -n semantic-router-test -l app.kubernetes.io/instance=${{ matrix.router-name }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$POD_NAME" ]; then
            kubectl logs $POD_NAME -n semantic-router-test --all-containers > /tmp/operator-logs/semantic-router.log || true
          fi

          kubectl get all -n semantic-router-test -o yaml > /tmp/operator-logs/resources.yaml || true

      - name: Upload logs as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: operator-integration-logs-${{ matrix.cache-backend }}
          path: /tmp/operator-logs/
          retention-days: 7

      - name: Clean up
        if: always()
        run: |
          kind delete cluster --name operator-test-${{ matrix.cache-backend }} || true
