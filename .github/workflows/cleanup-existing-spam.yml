name: Cleanup Existing Spam

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (only report, do not delete)'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      scan_issues:
        description: 'Scan open issues'
        required: false
        default: 'true'
        type: boolean
      scan_comments:
        description: 'Scan issue comments'
        required: false
        default: 'true'
        type: boolean
      max_issues:
        description: 'Max number of issues to scan (0 = all)'
        required: false
        default: '100'
        type: string

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Scan and cleanup spam
        uses: actions/github-script@v7
        env:
          # Uses the same hidden detection logic as the main filter
          SPAM_DETECTION_SCRIPT: ${{ secrets.SPAM_DETECTION_SCRIPT }}
        with:
          script: |
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const scanIssues = '${{ inputs.scan_issues }}' === 'true';
            const scanComments = '${{ inputs.scan_comments }}' === 'true';
            const maxIssues = parseInt('${{ inputs.max_issues }}') || 0;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            core.info(`Starting cleanup with hidden detection logic`);
            core.info(`  Dry run: ${dryRun}`);
            core.info(`  Scan issues: ${scanIssues}`);
            core.info(`  Scan comments: ${scanComments}`);
            core.info(``);
            
            // Load detection script from secret
            const detectionScript = process.env.SPAM_DETECTION_SCRIPT;
            
            if (!detectionScript) {
              core.error("SPAM_DETECTION_SCRIPT secret not found!");
              core.setFailed("Spam detection not configured");
              return;
            }
            
            // Create analyzer function (all logic hidden in secret)
            let analyzeContent;
            
            try {
              // Wrap the detection script to create a reusable analyzer
              const analyzerWrapper = `
                (async function(github, context, core) {
                  ${detectionScript}
                })
              `;
              
              // Execute to get the detection capabilities
              const detectionModule = eval(analyzerWrapper);
              await detectionModule(github, context, core);
              
              // Create a mock context for analysis
              analyzeContent = async function(body, actor, assoc) {
                // Create mock event for analysis
                const mockContext = {
                  ...context,
                  eventName: 'issues',
                  payload: {
                    issue: {
                      body: body,
                      user: { login: actor },
                      author_association: assoc,
                      number: 0
                    },
                    action: 'opened'
                  }
                };
                
                // Run detection on mock event
                let isSpam = false;
                let reason = "Clean";
                let score = 0;
                
                // Capture the detection result by checking if action would be taken
                const originalUpdate = github.rest.issues.update;
                const originalDelete = github.rest.issues.deleteComment;
                
                let detectionResult = { isSpam: false };
                
                github.rest.issues.update = async (params) => {
                  detectionResult = { isSpam: true, reason: "Would close", score: 2 };
                  return { data: {} };
                };
                
                github.rest.issues.deleteComment = async (params) => {
                  detectionResult = { isSpam: true, reason: "Would delete", score: 2 };
                  return { data: {} };
                };
                
                github.rest.issues.createComment = async () => ({ data: {} });
                github.rest.pulls.update = async () => ({ data: {} });
                github.rest.pulls.deleteReviewComment = async () => ({ data: {} });
                
                try {
                  await detectionModule(github, mockContext, core);
                } catch (e) {
                  // Ignore errors from mock execution
                }
                
                // Restore original functions
                github.rest.issues.update = originalUpdate;
                github.rest.issues.deleteComment = originalDelete;
                
                return detectionResult;
              };
              
              core.info("✅ Loaded spam detection from secret");
              core.info("");
              
            } catch (err) {
              core.error(`Failed to load detection: ${err.message}`);
              core.setFailed(`Detection script error`);
              return;
            }
            
            let totalScanned = 0;
            let totalSpam = 0;
            let totalClosed = 0;
            let totalDeleted = 0;
            
            // Scan issues
            if (scanIssues) {
              core.info("Scanning open issues...");
              let page = 1;
              
              while (maxIssues === 0 || totalScanned < maxIssues) {
                const issues = await github.rest.issues.listForRepo({
                  owner, repo, state: 'open', per_page: 100, page
                });
                
                if (issues.data.length === 0) break;
                
                for (const issue of issues.data) {
                  if (issue.pull_request) continue;
                  if (maxIssues > 0 && totalScanned >= maxIssues) break;
                  
                  totalScanned++;
                  const analysis = await analyzeContent(
                    issue.body || "",
                    issue.user?.login || "unknown",
                    issue.author_association || "NONE"
                  );
                  
                  if (analysis.isSpam) {
                    totalSpam++;
                    core.warning(`[SPAM] Issue #${issue.number} by @${issue.user?.login}`);
                    core.warning(`  Preview: ${(issue.body || "").substring(0, 150)}...`);
                    
                    if (!dryRun) {
                      try {
                        await github.rest.issues.update({
                          owner, repo, issue_number: issue.number,
                          state: "closed", state_reason: "not_planned"
                        });
                        await github.rest.issues.createComment({
                          owner, repo, issue_number: issue.number,
                          body: "This issue has been automatically closed as spam during cleanup."
                        });
                        totalClosed++;
                        core.notice(`✓ Closed spam issue #${issue.number}`);
                      } catch (err) {
                        core.error(`✗ Failed to close issue #${issue.number}: ${err.message}`);
                      }
                    }
                  }
                }
                page++;
              }
            }
            
            // Scan comments
            if (scanComments) {
              core.info("Scanning issue comments...");
              let page = 1;
              let commentCount = 0;
              
              while (page <= 10) {
                const comments = await github.rest.issues.listCommentsForRepo({
                  owner, repo, per_page: 100, page, sort: 'created', direction: 'desc'
                });
                
                if (comments.data.length === 0) break;
                
                for (const comment of comments.data) {
                  commentCount++;
                  const analysis = await analyzeContent(
                    comment.body || "",
                    comment.user?.login || "unknown",
                    comment.author_association || "NONE"
                  );
                  
                  if (analysis.isSpam) {
                    totalSpam++;
                    core.warning(`[SPAM] Comment #${comment.id} by @${comment.user?.login}`);
                    core.warning(`  Preview: ${(comment.body || "").substring(0, 150)}...`);
                    
                    if (!dryRun) {
                      try {
                        await github.rest.issues.deleteComment({
                          owner, repo, comment_id: comment.id
                        });
                        totalDeleted++;
                        core.notice(`✓ Deleted spam comment #${comment.id}`);
                      } catch (err) {
                        core.error(`✗ Failed to delete comment #${comment.id}: ${err.message}`);
                      }
                    }
                  }
                }
                page++;
              }
              
              core.info(`Scanned ${commentCount} comments`);
            }
            
            // Summary
            core.notice("=".repeat(60));
            core.notice(`Cleanup Summary ${dryRun ? '(DRY RUN)' : '(EXECUTED)'}`);
            core.notice(`Total scanned: ${totalScanned} issues`);
            core.notice(`Total spam found: ${totalSpam}`);
            if (!dryRun) {
              core.notice(`Issues closed: ${totalClosed}`);
              core.notice(`Comments deleted: ${totalDeleted}`);
            } else {
              core.notice("DRY RUN - No actions taken. Set dry_run to 'false' to execute.");
            }
            core.notice("=".repeat(60));
